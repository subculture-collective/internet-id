name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version tag to deploy (e.g., v1.0.0 or git SHA)"
        required: true
        type: string
      skip_tests:
        description: "Skip smoke tests after deployment (NOT RECOMMENDED)"
        required: false
        default: "false"
        type: boolean

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  API_IMAGE_NAME: ${{ github.repository }}-api
  WEB_IMAGE_NAME: ${{ github.repository }}-web

jobs:
  # Pre-deployment validation
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Validate version exists
        run: |
          if ! git rev-parse ${{ github.event.inputs.version }} >/dev/null 2>&1; then
            echo "‚ùå Version ${{ github.event.inputs.version }} does not exist"
            exit 1
          fi
          echo "‚úÖ Version ${{ github.event.inputs.version }} validated"

      - name: Check for breaking changes
        run: |
          echo "Checking for database migrations..."
          if git diff HEAD~1 HEAD -- prisma/schema.prisma | grep -q "^+"; then
            echo "‚ö†Ô∏è Database schema changes detected"
            echo "Ensure migrations are tested in staging first!"
          fi

  # Build and push production images
  build:
    name: Build Production Images
    runs-on: ubuntu-latest
    needs: validate

    outputs:
      api_image_tag: ${{ steps.meta-api.outputs.tags }}
      web_image_tag: ${{ steps.meta-web.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract API metadata
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.event.inputs.version }}
            type=raw,value=production-latest

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.api
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          target: runner

      - name: Extract Web metadata
        id: meta-web
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.WEB_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.event.inputs.version }}
            type=raw,value=production-latest

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./web/Dockerfile
          push: true
          tags: ${{ steps.meta-web.outputs.tags }}
          labels: ${{ steps.meta-web.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          target: runner

  # Deploy to production with manual approval
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: https://internet-id.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Create backup before deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/internet-id

            # Create pre-deployment backup
            docker compose -f docker-compose.production.yml exec -T backup \
              /opt/backup-scripts/backup-database.sh full

            echo "‚úÖ Pre-deployment backup completed"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        env:
          VERSION: ${{ github.event.inputs.version }}
          COMPOSE_FILE: docker-compose.production.yml
          API_IMAGE: ${{ needs.build.outputs.api_image_tag }}
          WEB_IMAGE: ${{ needs.build.outputs.web_image_tag }}
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          envs: VERSION,COMPOSE_FILE,API_IMAGE,WEB_IMAGE
          script: |
            cd /opt/internet-id

            # Record current version for rollback
            git rev-parse HEAD > .deployment-backup

            # Pull new version
            git fetch origin
            git checkout $VERSION

            # Pull new images
            # Note: GITHUB_TOKEN is used for container registry authentication
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin > /dev/null 2>&1
            docker compose -f $COMPOSE_FILE pull

            # Run database migrations
            echo "Running database migrations..."
            docker compose -f $COMPOSE_FILE run --rm api npx prisma migrate deploy

            # Blue-green deployment: Start new containers
            echo "Starting new containers..."
            docker compose -f $COMPOSE_FILE up -d --no-deps --scale api=4 --scale web=4 api web

            # Wait for new containers to be healthy
            echo "Waiting for health checks..."
            sleep 30

            # Verify health
            for i in {1..5}; do
              if docker compose -f $COMPOSE_FILE ps api | grep -q "healthy"; then
                echo "‚úÖ New containers are healthy"
                break
              fi
              if [ $i -eq 5 ]; then
                echo "‚ùå Health check failed"
                exit 1
              fi
              sleep 10
            done

            # Scale down old containers
            echo "Scaling down old containers..."
            docker compose -f $COMPOSE_FILE up -d --no-deps --scale api=2 --scale web=2 api web

            # Final cleanup
            docker image prune -af --filter "until=48h"

            echo "‚úÖ Production deployment completed"

      - name: Wait for stabilization
        run: sleep 60

      - name: Run smoke tests
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        run: |
          echo "Running smoke tests against production environment..."

          # Health check for API
          API_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" https://internet-id.example.com/api/health)
          if [ "$API_HEALTH" != "200" ]; then
            echo "‚ùå API health check failed with status: $API_HEALTH"
            exit 1
          fi
          echo "‚úÖ API health check passed"

          # Health check for Web
          WEB_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" https://internet-id.example.com)
          if [ "$WEB_HEALTH" != "200" ]; then
            echo "‚ùå Web health check failed with status: $WEB_HEALTH"
            exit 1
          fi
          echo "‚úÖ Web health check passed"

          # Check API metrics endpoint
          METRICS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://internet-id.example.com/api/metrics)
          if [ "$METRICS_STATUS" != "200" ]; then
            echo "‚ùå Metrics endpoint check failed"
            exit 1
          fi
          echo "‚úÖ Metrics endpoint check passed"

          # Check database connectivity
          NETWORK_STATUS=$(curl -s https://internet-id.example.com/api/network | jq -r '.chainId')
          if [ -z "$NETWORK_STATUS" ]; then
            echo "‚ùå API network check failed"
            exit 1
          fi
          echo "‚úÖ API network check passed (chainId: $NETWORK_STATUS)"

          # Verify content registration endpoint is accessible
          REGISTRY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://internet-id.example.com/api/registry)
          if [ "$REGISTRY_STATUS" != "200" ]; then
            echo "‚ùå Registry endpoint check failed"
            exit 1
          fi
          echo "‚úÖ Registry endpoint check passed"

          echo "üéâ All smoke tests passed!"

      - name: Notify success
        if: success()
        run: |
          echo "üéâ Production deployment successful!"
          echo "Version: ${{ github.event.inputs.version }}"
          # Add notification logic here (Slack, Discord, email, etc.)

      - name: Notify failure
        if: failure()
        run: |
          echo "‚ùå Production deployment failed!"
          echo "Immediate rollback recommended!"
          # Add notification logic here (Slack, Discord, email, etc.)

  # Rollback workflow
  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: [validate, build, deploy]
    if: failure()
    environment:
      name: production

    steps:
      - name: Emergency rollback
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/internet-id

            echo "üö® Initiating emergency rollback..."

            # Get previous version
            PREV_VERSION=$(cat .deployment-backup)

            if [ -z "$PREV_VERSION" ]; then
              echo "‚ùå No backup version found"
              exit 1
            fi

            # Checkout previous version
            git checkout $PREV_VERSION

            # Restore from backup if needed
            echo "Checking if database rollback is needed..."
            # docker compose -f docker-compose.production.yml exec -T backup \
            #   /opt/backup-scripts/restore-database.sh full

            # Rollback containers
            docker compose -f docker-compose.production.yml up -d --force-recreate

            # Wait for health
            sleep 30

            echo "‚úÖ Rollback completed to version: $PREV_VERSION"
            echo "‚ö†Ô∏è Manual verification required!"
